<script>
const csrf_token = document.querySelector('meta[name="csrf-token"]').content;


function dataFromJsonResponse(response){
    return new Promise((resolve, reject) => {
        Promise.resolve(response)
            .then(response => response.ok ? Promise.resolve(response) : Promise.reject(new Error(response.statusText)))
            .then(response => response.json())
            .then(data => data.error_message ? Promise.reject(new Error(data.error_message)) : resolve(data))
            .catch((e) => reject(e))
    });
}

function newFile(filename){
    fetch(`${history.state.currentDirectoryUrl}/${encodeURI(filename)}?touch=true`, {method: 'put', headers: { 'X-CSRF-Token': csrf_token }})
        .then(response => dataFromJsonResponse(response))
        .then(() => reloadTable())
        .catch(e => alertError('Error occurred when attempting to create new file', e.message));
}

function newDirectory(filename){
    fetch(`${history.state.currentDirectoryUrl}/${encodeURI(filename)}?dir=true`, {method: 'put', headers: { 'X-CSRF-Token': csrf_token }})
        .then(response => dataFromJsonResponse(response))
        .then(() => reloadTable())
        .catch(e => alertError('Error occurred when attempting to create new directory', e.message));
}

function reloadTable(url){
    var request_url = url || history.state.currentDirectoryUrl;

    return fetch(request_url, {headers: {'Accept':'application/json'}})
        .then(response => dataFromJsonResponse(response))
        .then(function(data) {
            $('#shell-wrapper').replaceWith((data.shell_dropdown_html))

            table.clear();
            table.rows.add(data.files);
            table.draw();

            $('#open-in-terminal-btn').attr('href', data.shell_url);
            $('#open-in-terminal-btn').removeClass('disabled');

            return Promise.resolve(data);
        })
        .catch((e) => {
            alert(e.message, `Error occurred when attempting to access ${request_url}`, 'error');

            $('#open-in-terminal-btn').addClass('disabled');
            return Promise.reject(e);
        });
}

function goto(url, pushState = true, show_processing_indicator = true) {
    if(url == history.state.currentDirectoryUrl)
        pushState = false;

    reloadTable(url)
        .then((data) => {
            $('#path-breadcrumbs').html(data.breadcrumbs_html);

            if(pushState) {
                // Clear search query when moving to another directory.
                table.search('').draw();

                history.pushState({
                    currentDirectory: data.path,
                    currentDirectoryUrl: data.url
                }, data.name, data.url);
            }
        })
        .finally(() => {
            //TODO: after processing is available via ActiveJobs merge
            // if(show_processing_indicator)
            //   table.processing(false)
        });
}

function loading(title){

}

function doneLoading(){
}

history.replaceState({
  currentDirectory: '<%= @path %>',
  currentDirectoryUrl: '<%= files_path(@path) %>',
  currentDirectoryUpdatedAt: '<%= Time.now.to_i %>'
}, null);

$.fn.dataTable.ext.search.push(
    function( settings, data, dataIndex  ) {
      return getShowDotFiles() || ! data[2].startsWith('.');
    }
)

function update_datatables_status(api){
  // from "function info ( api )" of https://cdn.datatables.net/select/1.3.1/js/dataTables.select.js
  let rows    = api.rows( { selected: true } ).flatten().length,
      page_info = api.page.info(),
      msg = page_info.recordsTotal == page_info.recordsDisplay ? `Showing ${page_info.recordsDisplay} rows` : `Showing ${page_info.recordsDisplay} of ${page_info.recordsTotal} rows`;

  $('.datatables-status').html(`${msg} - ${rows} rows selected`);
}

function getShowOwnerMode() {
  return localStorage.getItem('show-owner-mode') == 'true'
}

function getShowDotFiles() {
  return localStorage.getItem('show-dotfiles') == 'true'
}

function setShowOwnerMode(visible) {
  localStorage.setItem('show-owner-mode', new Boolean(visible));
}

function setShowDotFiles(visible) {
  localStorage.setItem('show-dotfiles', new Boolean(visible));
}

function updateDotFileVisibility() {
  table.draw();
}

function updateShowOwnerModeVisibility() {
  let visible = getShowOwnerMode();

  table.column('owner:name').visible(visible);
  table.column('mode:name').visible(visible);
}

var table = $('#directory-contents').on('xhr.dt', function ( e, settings, json, xhr ) {
  // new ajax request for new data so update date/time
  if(json && json.time){
    history.replaceState(_.merge({}, history.state, {currentDirectoryUpdatedAt: json.time}), null);
  }
}).DataTable({
  autoWidth: false,
  language: {
    search: 'Filter:',
  },
  order: [[1, "asc"], [2, "asc"]],
  rowId: 'id',
  paging:false,
  scrollCollapse: true,
  select: {
    style: 'os',
    className: 'selected',
    toggleable: true,
    // don't trigger select checkbox column as select
    // if you need to omit more columns, use a "selectable" class on the columns you want to support selection
    selector: 'td:not(:first-child)'
  },
  // https://datatables.net/reference/option/dom
  // dom: '', dataTables_info nowrap
  //
  // put breadcrmbs below filter!!!
  dom: "<'row'<'col-sm-12'f>>" + // normally <'row'<'col-sm-6'l><'col-sm-6'f>> but we disabled pagination so l is not needed (dropdown for selecting # rows)
       "<'row'<'col-sm-12'<'dt-status-bar'<'datatables-status float-right'><'transfers-status'>>>>"+
       "<'row'<'col-sm-12'tr>>", // normally this is <'row'<'col-sm-5'i><'col-sm-7'p>> but we disabled pagination so have info take whole row
  columns: [
    {
      data: null,
      orderable: false,
      defaultContent: '<input type="checkbox">',
      render: function(data, type, row, meta) {
        var api = new $.fn.dataTable.Api( meta.settings );
        let selected = api.rows(meta.row, { selected: true }).count() > 0;
        return `<input type="checkbox" ${selected ? 'checked' : ''}> ${selected ? 'checked' : ''}`;
      }
    },
    { data: 'type', render: (data, type, row, meta) => data == 'd' ? '<span title="directory" class="fa fa-folder" style="color: gold"><span class="sr-only"> dir</span></span>' : '<span title="file" class="fa fa-file" style="color: lightgrey"><span class="sr-only"> file</span></span>' }, // type
    { name: 'name', data: 'name', className: 'text-break', render: (data, type, row, meta) => `<a class="${row.type} name ${row.type == 'd' ? '' : 'view-file' }" href="${row.url}">${Handlebars.escapeExpression(data)}</a>` }, // name
    { name: 'actions', orderable: false, data: null, render: (data, type, row, meta) => actionsBtnTemplate({ row_index: meta.row, file: row.type != 'd', data: row  }) }, // FIXME: pass row index or something needed for finding item
    { data: 'size',
      render: (data, type, row, meta) => {
        return type == "display" ? row.human_size : data;
      }
    }, // human_size
    { data: 'modified_at', render: (data, type, row, meta) => {
      if(type == "display"){
        let date = new Date(data * 1000)

        // Return formatted date "3/23/2021 10:52:28 AM"
        return isNaN(data) ? 'Invalid Date' : `${date.toLocaleDateString()} ${date.toLocaleTimeString()}`
      }
      else{
        return data;
      }
    }}, // modified_at
    { name: 'owner', data: 'owner', visible: getShowOwnerMode() }, // owner
    { name: 'mode', data: 'mode', visible: getShowOwnerMode(), render: (data, type, row, meta) => {

      // mode after base conversion is a string such as "100755"
      let mode = data.toString(8)

      // only care about the last 3 bits (755)
      let chmodDisplay = mode.substring(mode.length - 3)

      return chmodDisplay
    }} // mode
  ]
});

// prepend show dotfiles checkbox to search box
$('#directory-contents_filter').prepend(`<label style="margin-right: 20px" for="show-dotfiles"><input type="checkbox" id="show-dotfiles" ${ getShowDotFiles() ? 'checked' : ''}> Show Dotfiles</label>`)
$('#directory-contents_filter').prepend(`<label style="margin-right: 14px" for="show-owner-mode"><input type="checkbox" id="show-owner-mode" ${ getShowOwnerMode() ? 'checked' : ''}> Show Owner/Mode</label>`)

table.on('draw.dtSelect.dt select.dtSelect.dt deselect.dtSelect.dt info.dt', function () {
  update_datatables_status(table);
});

<% unless alert %>
// initial data load
reloadTable("/pun/sys/dashboard/files/fs/hpc/");
<% end %>

$('#show-dotfiles').on('change', () => {
  let visible = $('#show-dotfiles').is(':checked');

  setShowDotFiles(visible);
  updateDotFileVisibility();
});

$('#show-owner-mode').on('change', () => {
  let visible = $('#show-owner-mode').is(':checked');

  setShowOwnerMode(visible);
  updateShowOwnerModeVisibility();
});

$('#path-breadcrumbs').on('click', '#goto-btn', function(){

});

$('#new-file-btn').on("click", () => {

});

$('#new-dir-btn').on("click", () => {

});


function downloadFile(file) {
  // creating the temporary iframe is exactly what the CloudCmd does
  // so this just repeats the status quo

  let filename = $($.parseHTML(file.name)).text(),
      downloadUrl = `${history.state.currentDirectoryUrl}/${encodeURI(filename)}?download=${Date.now().toString()}`,
      iframe = document.createElement('iframe'),
      TIME = 30 * 1000;

  iframe.setAttribute('class', 'd-none');
  iframe.setAttribute('src', downloadUrl);

  document.body.appendChild(iframe);

  setTimeout(function() {
    document.body.removeChild(iframe);
  }, TIME);
}

function getEmptyDirs(entry){
  return new Promise((resolve) => {
    if(entry.isFile){
      resolve([]);
    }
    else{
      // getFilesAndDirectoriesFromDirectory has no return value, so turn this into a promise
      getFilesAndDirectoriesFromDirectory(entry.createReader(), [], function(error){ console.error(error)}, {
        onSuccess: (entries) => {
          if(entries.length == 0){
            // this is an empty directory
            resolve([entry]);
          }
          else{
            Promise.all(entries.map(e => getEmptyDirs(e))).then((dirs) => resolve(_.flattenDeep(dirs)));
          }
        }
      })
    }
  });
}

// https://github.com/transloadit/uppy/blob/7ce58beeb620df3df0640cb369f5d71e3d3f751f/packages/%40uppy/utils/src/getDroppedFiles/utils/webkitGetAsEntryApi/getFilesAndDirectoriesFromDirectory.js
/**
 * Recursive function, calls the original callback() when the directory is entirely parsed.
 *
 * @param {FileSystemDirectoryReader} directoryReader
 * @param {Array} oldEntries
 * @param {Function} logDropError
 * @param {Function} callback - called with ([ all files and directories in that directoryReader ])
 */
function getFilesAndDirectoriesFromDirectory (directoryReader, oldEntries, logDropError, { onSuccess }) {
  directoryReader.readEntries(
    (entries) => {
      const newEntries = [...oldEntries, ...entries]
      // According to the FileSystem API spec, getFilesAndDirectoriesFromDirectory() must be called until it calls the onSuccess with an empty array.
      if (entries.length) {
        setTimeout(() => {
          getFilesAndDirectoriesFromDirectory(directoryReader, newEntries, logDropError, { onSuccess })
        }, 0)
      // Done iterating this particular directory
      } else {
        onSuccess(newEntries)
      }
    },
    // Make sure we resolve on error anyway, it's fine if only one directory couldn't be parsed!
    (error) => {
      logDropError(error)
      onSuccess(oldEntries)
    }
  )
}

window.onpopstate = function(event){
  // FIXME: handle edge case if state ! exist
  setTimeout(() => {
    goto(event.state.currentDirectoryUrl, false);
  }, 0);
};

// borrowed from Turbolinks
// event: MouseEvent
function clickEventIsSignificant(event) {
  return !(
    // (event.target && (event.target as any).isContentEditable)
       event.defaultPrevented
    || event.which > 1
    || event.altKey
    || event.ctrlKey
    || event.metaKey
    || event.shiftKey
  )
}

// this would be perfect for stimulus FYI
$('#directory-contents tbody').on('click', '.view-file', function(e){
  e.preventDefault();

  window.open(this.href, 'ViewFile', "location=yes,resizable=yes,scrollbars=yes,status=yes");
});

$('#directory-contents tbody').on('click', '.delete-file', function(e){
  e.preventDefault();

  let row = table.row(this.dataset.rowIndex).data();
  deleteFiles([row.name]);
});

$('#directory-contents tbody').on('click', '.download-file', function(e){
  e.preventDefault();

  let file = table.row(this.dataset.rowIndex).data();

  if(file.type == 'd') {
    downloadDirectory(file)
  }
  else {
    downloadFile(file)
  }
});

$('#directory-contents tbody').on('click', '.rename-file', function(e){
  e.preventDefault();

  let row = table.row(this.dataset.rowIndex).data();

  // if there was some other attribute that just had the name...
  let filename = $($.parseHTML(row.name)).text();

});

$('#directory-contents tbody, #path-breadcrumbs, #favorites').on('click', 'a.d', function(){
  if(clickEventIsSignificant(event)){
    event.preventDefault();
    event.cancelBubble = true;
    if(event.stopPropagation) event.stopPropagation();

    goto(this.getAttribute("href"));
  }
});

$('#directory-contents tbody').on('dblclick', 'tr td:not(:first-child)', function(){
    // handle doubleclick
    let a = this.parentElement.querySelector('a');
    if(a.classList.contains('d')) goto(a.getAttribute("href"));
});

function clearClipboard(){
   localStorage.removeItem('filesClipboard');
}

function updateClipboardFromSelection(){
  let selection = table.rows({selected: true}).data();
  if(selection.length == 0){
    clearClipboard();
  }
  else {
    let clipboardData = {
      from: history.state.currentDirectory,
      files: selection.toArray().map((f) => {
          return { directory: f.type == 'd', name: f.name };
      })
    };

    localStorage.setItem('filesClipboard', JSON.stringify(clipboardData));
  }
}

const reportTransferTemplate = (function(){
  let template_str  = $('#transfer-template').html();
  // return Handlebars.compile(template_str);
})();

function findAndUpdateTransferStatus(data){
  let id = `#${data.id}`;

  if($(id).length){
    $(id).replaceWith(reportTransferTemplate(data));
  }
  else{
    $('.transfers-status').append(reportTransferTemplate(data));
  }
}

function fadeOutTransferStatus(data){
  let id = `#${data.id}`;
  $(id).fadeOut(4000);
}


function reportTransfer(data){
  // 1. add the transfer label
  findAndUpdateTransferStatus(data);

  let attempts = 0

  // 2. poll for the updates
  var poll = function() {
    $.getJSON(data.show_json_url, function (newdata) {
      findAndUpdateTransferStatus(newdata);

      if(newdata.completed) {
        if(! newdata.error_message) {
          if(newdata.target_dir == history.state.currentDirectory) {
            reloadTable();
          }

          // 3. fade out after 5 seconds
          fadeOutTransferStatus(newdata)
        }
      }
      else {
        // not completed yet, so poll again
        setTimeout(poll, 1000);
      }
    }).fail(function() {
      if (attempts >= 3) {
        alert('Operation may not have happened', 'Failed to retrieve file operation status.', 'error');
      } else {
        setTimeout(poll, 1000);
        attempts++;
      }
    });
  }

  poll();
}

function renameFile(filename, new_filename){
  let files = {};
  files[`${history.state.currentDirectory}/${filename}`] = `${history.state.currentDirectory}/${new_filename}`;
  transferFiles(files, "mv", "rename file")
}

function moveFiles(files, summary = "move files"){
  transferFiles(files, "mv", "move files")
}

function copyFiles(files){
  transferFiles(files, "cp", "copy files")
}

function removeFiles(files){
  transferFiles(files, "rm", "remove files")
}

function updateViewForClipboard(){
  let clipboard = JSON.parse(localStorage.getItem('filesClipboard') || '{}'),
      template_str  = $('#clipboard-template').html();
      // template = Handlebars.compile(template_str);

  // $('#clipboard').html(template(clipboard));

  $('#clipboard-clear').on("click", () => {
      clearClipboard();
      updateViewForClipboard();
  });


  $('#clipboard-copy-to-dir').on("click", () => {
    let clipboard = JSON.parse(localStorage.getItem('filesClipboard') || 'null');

    if(clipboard){
      clipboard.to = history.state.currentDirectory;

      if(clipboard.from == clipboard.to){
        console.error('clipboard from and to are identical')

        // TODO: we want to support this use case
        // copy and paste as a new filename
        // but lots of edge cases
        // (overwrite or rename duplicates)
        // _copy
        // _copy_2
        // _copy_3
        // _copy_4
      }
      else{
        // [{"/from/file/path":"/to/file/path" }]
        let files = {};
        clipboard.files.forEach((f) => {
          files[`${clipboard.from}/${f.name}`] = `${history.state.currentDirectory}/${f.name}`
        });

        copyFiles(files, csrf_token);
      }
    }
    else{
      console.error('files clipboard is empty');
    }
  });

  $('#clipboard-move-to-dir').on("click", () => {
    let clipboard = JSON.parse(localStorage.getItem('filesClipboard') || 'null');

    if(clipboard){
      clipboard.to = history.state.currentDirectory;

      if(clipboard.from == clipboard.to){
        console.error('clipboard from and to are identical')
        // TODO:
      }
      else{
        let files = {};
        clipboard.files.forEach((f) => {
          files[`${clipboard.from}/${f.name}`] = `${history.state.currentDirectory}/${f.name}`
        });

        moveFiles(files, csrf_token);
      }
    }
    else{
      console.error('files clipboard is empty');
    }
  });
}

$('#copy-move-btn').on("click", () => {
    updateClipboardFromSelection();
    updateViewForClipboard();
});

function deleteFiles(files){
  if(! files.length > 0){
    return;
  }
}

$('#delete-btn').on("click", () => {
  let files = table.rows({selected: true}).data().toArray().map((f) => f.name);
  deleteFiles(files);
});

// TODO: move all functionality out of click handlers to functions
// TODO: disable copy/move buttons if no local storage

//FIXME: so need to handle updateViewForClipboard based on EVENTS emitted by local storage modifications
updateViewForClipboard();
window.addEventListener('storage', () => {
  updateViewForClipboard();
});

// if only 1 selected item, do not allow to de-select
table.on('user-select', function ( e, dt, type, cell, originalEvent  ) {
    var selected_rows = dt.rows( { selected: true  }  );

    if(originalEvent.target.closest('.actions-btn-group')){
      // dont do user select event when opening or working with actions btn dropdown
      e.preventDefault();
    }
    else if(selected_rows.count() == 1 && cell.index().row == selected_rows.indexes()[0] ){
      // dont do user select because already selected
      e.preventDefault();
    }
    else{
      // row need to find the checkbox to give it the focus
      cell.node().closest('tr').querySelector('input[type=checkbox]').focus();
    }
});

table.on( 'deselect', function ( e, dt, type, indexes ) {
  dt.rows(indexes).nodes().toArray().forEach(e => $(e).find('input[type=checkbox]').prop('checked', false));
});

table.on( 'select', function ( e, dt, type, indexes ) {
  dt.rows(indexes).nodes().toArray().forEach(e => $(e).find('input[type=checkbox]').prop('checked', true));
});

$('#directory-contents tbody').on('click', 'tr td:first-child input[type=checkbox]', function(){
  // input checkbox checked or not

  if($(this).is(':checked')){
    // select row
    table.row(this.closest('tr')).select();
  }
  else{
    // deselect row
    table.row(this.closest('tr')).deselect();
  }

  this.focus();
});

$('#directory-contents tbody').on('keydown', 'input, a', function(e){
  if(e.key == "ArrowDown"){
    e.preventDefault();

    // let tr = this.closest('tr').nextSibling;
    let tr = $(this.closest('tr')).next('tr').get(0);
    if(tr){
      tr.querySelector('input[type=checkbox]').focus();

      // deselect if not holding shift key to work
      // like native file browsers
      if(! e.shiftKey){
        table.rows().deselect();
      }

      // select if moving down
      table.row(tr).select();
    }
  }
  else if(e.key == "ArrowUp"){
    e.preventDefault();

    let tr = $(this.closest('tr')).prev('tr').get(0);
    if(tr){
      tr.querySelector('input[type=checkbox]').focus();

      // deselect if not holding shift key to work
      // like native file browsers
      if(! e.shiftKey){
        table.rows().deselect();
      }

      // select if moving up
      table.row(tr).select();
    }
  }
});

</script>
